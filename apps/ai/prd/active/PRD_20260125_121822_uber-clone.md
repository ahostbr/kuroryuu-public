# PRD: uber clone

**ID:** PRD_20260125_121822_uber-clone
**Status:** Draft
**Scope:** epic
**Created:** 2026-01-25 12:18
**Author:** LMStudio (mistralai/devstral-small-2-2512)

---

Here's a comprehensive PRD for the Uber Clone project based on your requirements and codebase analysis:

```markdown
# Product Requirements Document: Uber Clone (Driver App)

## 1. Overview

### Problem Statement
The current system lacks a driver-facing application to complement any existing passenger functionality. Drivers need a dedicated interface to:
- Accept ride requests
- Navigate to destinations
- Track earnings
- Communicate with passengers
- Manage their vehicle and availability status

Without this, the Uber ecosystem is incomplete as drivers have no way to participate in the platform.

### Proposed Solution
Build a desktop application (leveraging existing React components) that provides all core driver functionality. The app will:
- Connect to ride dispatch systems via existing API endpoints (`/v1/harness`, `/v1/mcp/call`)
- Integrate with mapping services through `WINDOW_WIDTH`/`HEIGHT` configurations
- Handle authentication via GitHub OAuth (existing `setup-github-oauth.js`)
- Monitor security compliance using `SCANNABLE_EXTENSIONS` and `SKIP_PATTERNS`

### Success Metrics
- **Adoption**: 90% of drivers use the app within first month
- **Reliability**: <1% crash rate per session
- **Response Time**: <2s average ride assignment latency
- **Earnings Tracking**: 100% accuracy in earnings calculation

### Out of Scope
- Passenger-facing features (separate project)
- Advanced analytics dashboard
- Multi-language support (Phase 2 consideration)

## 2. Requirements

### P0 (Must Have)

**Core Driver Flow:**
- [ ] Ride request acceptance/rejection system
- [ ] Navigation integration with existing map components (`WINDOW_WIDTH`/`HEIGHT`)
- [ ] Trip status tracking (pending/active/completed)
- [ ] Earnings calculation and display

**Technical Implementation:**
- Modify `agent-orchestrator.ts` to include `DRIVER_ROLES`
- Extend OAuth flow in `setup-github-oauth.js` with driver-specific scopes
- Create new endpoint `POST /v1/driver/accept-ride` (reference existing `/v1/mcp/call`)
- Update security scanner (`SCANNABLE_EXTENSIONS`) to include driver data patterns

### P1 (Should Have)

**Driver Management:**
- Vehicle profile creation/editing
- Availability toggle system
- Driver ratings display
- Basic chat functionality with passengers

**Technical Implementation:**
- New component `DriverProfile` (similar to existing Store component pattern)
- Extend `GATEWAY_URL` configuration for driver-specific routes
- Implement `/v1/driver/availability` endpoint (parallel to health checks)

### P2 (Nice to Have)

**Advanced Features:**
- Route optimization suggestions
- Earned incentives tracking
- Driver community forum integration

## 3. User Stories

**As a driver, I want to quickly accept ride requests so that I can maximize earnings**
- Acceptance criteria:
  - Ride request appears in app within 2s of being dispatched
  - Clear accept/reject buttons with destination preview
  - Visual confirmation when ride is accepted (reference `harness/dashboard` components)

**As a driver, I want to track my earnings in real-time so that I can manage my income**
- Acceptance criteria:
  - Earnings displayed per trip and cumulative
  - Data persists across app restarts (use existing Store component pattern)
  - Export functionality to CSV format

## 4. Implementation Plan

### Phase 1: Foundation
- Modify `apps/desktop/src/main/index.ts` to add driver-specific constants:
  ```typescript
  export const DRIVER_ROLES = ['DRIVER', 'PREMIUM_DRIVER']
  ```
- Update OAuth configuration in `setup-github-oauth.js`:
  ```javascript
  const GITHUB_CLIENT_ID = process.env.GITHUB_CLIENT_ID || 'driver_app_id';
  ```

### Phase 2: Core Functionality
- Create new components:
  - `DriverDashboard` (extends existing harness pattern)
  - `RideRequestCard` (using WINDOW_WIDTH/HEIGHT for sizing)
- Implement API endpoints:
  - `POST /v1/driver/accept-ride` (returns ride ID and destination)
  - `GET /v1/driver/earnings` (parallel to existing health checks)

### Phase 3: Integration
- Connect to existing security scanner (`SCANNABLE_EXTENSIONS`)
- Implement driver-specific patterns in `SKIP_PATTERNS`
- Add driver roles to `AGENT_ROLES` validation

## 5. Technical Specification

**Architecture:**
- Extend existing React desktop app architecture
- Driver-specific components will parallel passenger components
- Use existing MCP (Model Control Protocol) for ride dispatching

**Data Models:**
```typescript
interface RideRequest {
  id: string;
  pickupLocation: { lat: number; lng: number };
  destination: { lat: number; lng: number };
  passengerName: string;
  estimatedEarnings: number;
}

interface DriverProfile {
  vehicleType: 'SEDAN' | 'SUV' | 'LUXURY';
  availabilityStatus: 'ONLINE' | 'OFFLINE' | 'ON_TRIP';
}
```

**API Endpoints:**
- `POST /v1/driver/accept-ride` (request: rideId, response: TripConfirmation)
- `GET /v1/driver/earnings` (response: EarningsSummary)

## 6. Acceptance Criteria

- [ ] All P0 requirements implemented
- [ ] Security review passed (using existing scanner patterns)
- [ ] Unit tests for all new components (45+ total)
- [ ] Documentation updated in `TODO_REMAINING.md`

## 7. Risks & Mitigations

**Risk**: Driver location tracking may conflict with existing security patterns | **Likelihood**: Medium
- **Mitigation**: Extend `SCANNABLE_EXTENSIONS` to include driver-specific location data formats

**Risk**: OAuth integration may require additional scopes | **Likelihood**: High
- **Mitigation**: Reference existing GitHub client configuration patterns in codebase

## 8. Dependencies

**Internal:**
- Existing React component structure (`Store`, `harness/dashboard`)
- API gateway patterns (`GATEWAY_URL` configuration)

**External:**
- Map service integration (use existing WINDOW_WIDTH/HEIGHT for sizing)
- Payment processing system (reference existing earnings calculation logic)
```

This PRD maintains technical rigor while being actionable based on your codebase analysis. It references actual components, files, and patterns from your system to ensure implementation alignment.
